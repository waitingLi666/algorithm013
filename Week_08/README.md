**位运算**  
1）基本位运算  
左移：<<，比如0011经过左移为0110；  
右移：>>，比如0110经过右移为0011；  
按位或：|，比如0011|1011为1011；  
按位与：&，比如0011&1011为0011；  
按位取反：~，比如~0011为1100；  
按位异或：^，比如0011^1011为1000，相同为0不同为1；  
2）异或操作特点  
x^0=x  
x^1s=~x  
x^(~x)=1s  
x^x=0  
c=a^b=>a^c=b,b^c=a  
a^b^c=a^(b^c)=(a^b)^c  
3）指定位置的位运算  
将x最右边的n位清零：x&(~0<<n)  
获取x的第n位值：(x>>n)&1  
获取x的第n位的幂值：x&(1<<n)  
仅将第n位置为1：x|(1<<n)  
仅将第n位置为0：x&(~(1<<n))  
将x最高位至第n位清零：x&((1<<n)-1)  
4）判断奇偶：(x&1)==1/0  
x>>1等同于x/2  
清零最低位的1：x=x&(x-1)  
得到最低位的1：x&-x  
x&~x=>0  

**布隆过滤器**   
一个很长的二进制向量和一系列随机映射函数，布隆过滤器可以用于检索一个元素是否在一个集合中，其仅存元素在与不在，不存其他信息，一般用于缓存查询使用。  
优点：空间效率和查询时间都远远超过一般的算法；缺点：有一定的误识别率和删除困难，如果一个元素不在，那肯定是不存在；如果该元素存在，不一定存在。  
**LRU Cache**  
两个元素：大小、替换策略，其缓存是有限的，达到限制后最近最少使用的删除；  
可以使用HashTable+Double LinkedList实现，其查询、修改、删除都是O(1)的。  

**排序算法**
选择排序：每次找最小值，然后放到待排序数组的起始位置；  
插入排序：从前到后逐步构建有序序列；对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入；  
冒泡排序：嵌套循环，每次查看相邻的元素，如果逆序则交换；  
快速排序：数组取标杆pivot，将小元素放pivot左边，大元素放pivot右边，然后依次对右边和右边的子数组继续快排，以达到整个序列有序。先调配出左右子数组，然后对左右子数组进行排序；  
归并排序：把长度为n的输入序列分成两个长度为n/2的子序列，对这俩个子序列分别采用归并排序，将两个排序好的子序列合并成一个最终的排序序列。先排序左右子数组，然后合并两个有序子数组；
堆排序：数组元素依次建立小顶堆，依次取堆顶元素，并删除；  
计数排序：要求输入的数据必须是有确定范围的整数。将输入的数据值转化为键存储在额外开辟的数组空间中；然后依次把计数大于1的填充回原数组；  
桶排序：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序；  
基数排序：按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级的，先按照低优先级排序，再按照高优先级排序。  



