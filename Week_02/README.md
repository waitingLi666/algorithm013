HashMap总结(JDK1.8)：
1）HashMap内部的结构，可以看作是数组(Node<K,V>[]table)+链表+红黑树组成的复合结构，数组被分为一个个bucket，通过哈希值决定了键值对在这个数组的寻址；哈希值相同的键值对，则以链表的形式存储。如果超过阈值8，链表会改造为红黑树；小于等于6，解散红黑树。
2）HashMap在初始化时可以指定capacity和loadFactor，默认情况下，capacity为16，loadFactor最大为0.75。当HashMap中元素个数超过0.75*capacity(表示容量)的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，从而大大提高HashMap的性能。
3）put方法使用时，会调用putVal方法：初始化、赋值及树化、扩容。具体说明如下：
初始化和扩容：调用resize()方法。如果table是null，resize方法会负责初始化它；在容量不足时，resize会扩容，2倍。
赋值及树化：通过（n - 1） & hash 计算出的值作为table的下标i，并另p表示tab[i]，也就是该链表第一个节点的位置，判断p是否为null。为null，则调用newNode方法返回新节点赋值给tab[i]。不为null，首先判断key是否相同，相同则将p的引用赋值给e。然后分三种情况分析：p为红黑树节点，则调用TreeNode.putTreeVal方法处理；插入后仍然是链表，则赋值即可；插入后判断临界条件8，符合则调用treeifyBin方法转为红黑树处理。
4）get方法使用时，会调用getNode方法。根据key和hash值查询node节点，如果存在，则返回该节点的value值。根据key搜索节点，需要判断key是否相等：hash值相同且符合equals方法。根据hash值，可以直接计算出对应table的下标i=(n-1)&hash，在该table[i]上进行操作。若第一个存在的节点的key和查询的key相等，直接返回该节点；若table[i]上存储的是红黑树结构，调用getTreeNode方法，在内部遍历红黑树节点，查看是否有匹配的TreeNode；若table[i]存储的是链表结构，遍历链表获取结果。


学习内容总结：
本周主要学习哈希表、树(二叉树、二叉搜索树)、堆(二叉堆)、图数据结构。
1）哈希表：根据关键码值直接访问的数据结构。查找、删除、插入时间复杂度为O(1)。哈希表，关键的是哈希函数的设计，如果设计的不好的话，会造成经常碰撞。
2）树的遍历：前序遍历(根---左---右)，中序遍历(左---根---右)，后序遍历(左---右---根)。
3）二叉搜索树：可以是空树，或者符合左边所有节点值小于根节点，右边所有节点大于根节点。中序遍历二叉搜索树，是升序排序的。查询、删除、插入的时间复杂度为O(logn)。删除时，若是叶子节点，则直接删除；若为根或子根，则取第一个大于此点的进行替换。插入时，关键是先查找再创建。
4）堆：可迅速地找到一堆数中的最大或最小值的数据结构。根节点最大的堆叫大顶堆或大根堆，最小的堆叫小顶堆或小根堆。
5）二叉堆是通过完全二叉树实现的，可通过数组表示。插入操作时，新元素先插入到堆的尾部，然后依次向上调整整个堆的结构，一直到根即可。删除堆顶元素操作时，将堆尾元素替换到顶部，依次从根部向下调整整个堆的结构，一直到堆尾即可。
6）表示Graph(V,E)。其中V表示点，E表示边。




